# Projet Python
## Implémentation d’un malware

![03_shipping_malware-100694090-large
2](https://user-images.githubusercontent.com/69111687/89729811-6e7e8d80-da39-11ea-8876-1ab48efa9e64.jpg)
 

### 1. Les prérequis
Etape 1: avoir **installé python**. Ensuite ouvrez l'invite de commandes (CMD ou Powershell) et installer la librairie pycryptodome qui servira pour l'échange crypté, tapez **pip install pycryptodome**. Puis, sur la VM infecté il faut avoir au préalable désactiver le parefeu Windows et Windows Defender(ou tout autre antivirus). En dernier lieu, taper la  commande ipconfig pour avoir l'ip de la machine infectée en invite de commandes.

`!!! ATTENTION !!! L'utilisation de VM est fortement conseillé car le parefeu sera désactivé ainsi que l'antivirus. `

#### 1.1 Fonctionnement

Dans un premier temps, démarrer le programme Malware via un invite de commande sur la machine infectée.
![Capture](https://user-images.githubusercontent.com/69111687/89730531-b6a0ae80-da3f-11ea-983c-77d6491ace2e.PNG)

Sur le Client, toujours en invite de commande, tapez python le nom du programme et l'ip du Malware.
![Capture2](https://user-images.githubusercontent.com/69111687/89730737-f072b480-da41-11ea-86b7-89e4298f4c9a.PNG)

### 2. Les concepts utilisés

#### 2.1 Les sockets

Les sockets sont basés sur l'utilisation du protocole TCP/IP. Il faut donc par conséquent renseigné des IP et des numéros de port pour que la communication puisse s'établir.

![Capture3](https://user-images.githubusercontent.com/69111687/89731303-3c275d00-da46-11ea-9fa0-48892c479cff.PNG)

Le serveur étant considéré comme le Malware dans notre cas.

Le malware :
1. créé un socket : .socket(socket.AF_INET, socket.SOCK_STREAM) entre parenthèse nous précisont que ce doit du tcp et non de l'udp.
1. attend une connexion de la part du client (gràce au port et a une IP): .bind(ip, port) puis .listen() 
2. accepte la connexion quand le client se connecte : .accept()
3. échange des informations avec le client ( recevoir et envoyer des bytes) : .send() et .receive() 
4. ferme la connexion: .close()

Le client:

1. créé un socket: .socket(socket.AF_INET, socket.SOCK_STREAM) entre parenthèse nous précisont que ce doit du tcp et non de l'udp.
2. se connecte au serveur: .connect(ip, port)
3. échange des informations avec le serveur: .send() et /receive()
4. ferme la connexion: .close()

#### 2.2 Subprocess

Il permet de lancer de nouveaux processus, les connecter à des tubes (PIPE) d'entrée/sortie/erreur, et d'obtenir leurs codes de retour. Utile pour ravoir un retour du résultat d’une commande lors du remote shell.


