# Projet Python
## Implémentation d’un malware

![03_shipping_malware-100694090-large
2](https://user-images.githubusercontent.com/69111687/89729811-6e7e8d80-da39-11ea-8876-1ab48efa9e64.jpg)
 

### 1. Les prérequis
Etape 1: avoir **installé python**. Ensuite ouvrez l'invite de commandes (CMD ou Powershell) et installer la librairie pycryptodome qui servira pour l'échange crypté, tapez **pip install pycryptodome**. Puis, sur la VM infecté il faut avoir au préalable désactiver le parefeu Windows et Windows Defender(ou tout autre antivirus). En dernier lieu, taper la  commande ipconfig pour avoir l'ip de la machine infectée en invite de commandes.

`!!! ATTENTION !!! L'utilisation de VM est fortement conseillé car le parefeu sera désactivé ainsi que l'antivirus. `

#### 1.1 Fonctionnement

Dans un premier temps, démarrer le programme Malware via un invite de commande sur la machine infectée.
![Capture](https://user-images.githubusercontent.com/69111687/89730531-b6a0ae80-da3f-11ea-983c-77d6491ace2e.PNG)

Sur le Client, toujours en invite de commande, tapez python le nom du programme et l'ip du Malware.
![Capture2](https://user-images.githubusercontent.com/69111687/89730737-f072b480-da41-11ea-86b7-89e4298f4c9a.PNG)

Si la connection est établie entre Malware et client un Menu doit apparaitre.

![Capture23](https://user-images.githubusercontent.com/69111687/89738004-9c81c300-da75-11ea-90a7-6b72d9fdc27c.PNG)

1. Get Directory : permet d'afficher le contenu de répertoire Downloads
2. Remote shell : permet de taper des commandes Windows 

### 2. Les concepts utilisés

#### 2.1 Les sockets

Les sockets sont basés sur l'utilisation du protocole TCP/IP. Il faut donc par conséquent renseigné des IP et des numéros de port pour que la communication puisse s'établir.

![Capture3](https://user-images.githubusercontent.com/69111687/89731303-3c275d00-da46-11ea-9fa0-48892c479cff.PNG)

Le serveur étant considéré comme le Malware dans notre cas.

Le malware :
1. créé un socket : .socket(socket.AF_INET, socket.SOCK_STREAM) entre parenthèse nous précisont que ce doit du tcp et non de l'udp.
1. attend une connexion de la part du client (gràce au port et a une IP): .bind(ip, port) puis .listen() 
2. accepte la connexion quand le client se connecte : .accept()
3. échange des informations avec le client ( recevoir et envoyer des bytes) : .send() et .receive() 
4. ferme la connexion: .close()

Le client:

1. créé un socket: .socket(socket.AF_INET, socket.SOCK_STREAM) entre parenthèse nous précisont que ce doit du tcp et non de l'udp.
2. se connecte au serveur: .connect(ip, port)
3. échange des informations avec le serveur: .send() et .receive()
4. ferme la connexion: .close()

#### 2.2 Subprocess

Il permet de lancer de nouveaux processus, les connecter à des tubes (PIPE) d'entrée/sortie/erreur, et d'obtenir leurs codes de retour. Utile pour ravoir un retour du résultat d’une commande lors du remote shell.

![images](https://user-images.githubusercontent.com/69111687/89731823-65e28300-da4a-11ea-8577-f04462c95642.png)

#### 2.3 Pycryptodome

Plusieurs méthodes de cryptage existent, ici nous nous sommes basés sur le module Pycryptodome qui reste la façon la plus simple de crypter une communication. 
Il utilise le cryptage symétrique (utilisation de la même clé pour déchiffrer et chiffrer). Ici le Protocole AES a été utilisé. C’est un chiffrement par blocs. Nous avons utilisé Le mode CFB chiffrement à rétroaction, en anglais "Cipher Feedback". Il permet de chiffrer les données par unités plus petites que la taille de bloc. 
Le choix du mode se fait suivant l’utilisation de celui-ci. 

Ici le choix le plus judicieux est le CFB, pour cause, il est utilisé pour chiffrer en continu des flots de caractères quand chaque caractère doit être traité individuellement, comme c’est le cas pour le lien entre un terminal et un ordinateur central (client / serveur).

![900px-Schema_cfb](https://user-images.githubusercontent.com/69111687/89737265-f2ec0300-da6f-11ea-80af-9325d2cc1ba1.png)


#### 2.4 La gestion des erreurs

La notion d’exception : une exception est un mécanisme d’interruption du programme utilisé pour signaler que quelque chose d’anormal est en train de se produire.
Voici comment se compose une exception en Python:

> try {code} except {code}

Le bloc try permet de mettre les instructions que nous souhaitons tester dans un premier bloc et les instructions à exécuter en cas d'erreur dans un autre bloc except, qui sera exécuté si une erreur est trouvée dans le premier bloc.






